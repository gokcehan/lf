.\" Automatically generated by Pandoc 2.11.4
.\"
.TH "LF" "1" "2024-07-01" "" "DOCUMENTATION"
.hy
.SH NAME
.PP
lf - terminal file manager
.SH SYNOPSIS
.PP
\f[B]lf\f[R] [\f[B]-command\f[R] \f[I]command\f[R]] [\f[B]-config\f[R]
\f[I]path\f[R]] [\f[B]-cpuprofile\f[R] \f[I]path\f[R]] [\f[B]-doc\f[R]]
[\f[B]-last-dir-path\f[R] \f[I]path\f[R]] [\f[B]-log path\f[R]]
[\f[B]-memprofile\f[R] \f[I]path\f[R]] [\f[B]-print-last-dir\f[R]]
[\f[B]-print-selection\f[R]] [\f[B]-remote\f[R] \f[I]command\f[R]]
[\f[B]-selection-path\f[R] \f[I]path\f[R]] [\f[B]-server\f[R]]
[\f[B]-single\f[R]] [\f[B]-version\f[R]] [\f[B]-help\f[R]]
[\f[I]cd-or-select-path\f[R]]
.SH DESCRIPTION
.PP
lf is a terminal file manager.
.PP
The source code can be found in the repository at
<https://github.com/gokcehan/lf>
.PP
This documentation can either be read from the terminal using
\f[C]lf -doc\f[R] or online at
<https://github.com/gokcehan/lf/blob/master/doc.md> You can also use the
\f[C]doc\f[R] command (default \f[C]<f-1>\f[R]) inside lf to view the
documentation in a pager.
A man page with the same content is also available in the repository at
<https://github.com/gokcehan/lf/blob/master/lf.1>
.PP
You can run \f[C]lf -help\f[R] to see descriptions of command line
options.
.SH QUICK REFERENCE
.PP
The following commands are provided by lf:
.IP
.nf
\f[C]
quit                     (default \[aq]q\[aq])
up                       (default \[aq]k\[aq] and \[aq]<up>\[aq])
half-up                  (default \[aq]<c-u>\[aq])
page-up                  (default \[aq]<c-b>\[aq] and \[aq]<pgup>\[aq])
scroll-up                (default \[aq]<c-y>\[aq])
down                     (default \[aq]j\[aq] and \[aq]<down>\[aq])
half-down                (default \[aq]<c-d>\[aq])
page-down                (default \[aq]<c-f>\[aq] and \[aq]<pgdn>\[aq])
scroll-down              (default \[aq]<c-e>\[aq])
updir                    (default \[aq]h\[aq] and \[aq]<left>\[aq])
open                     (default \[aq]l\[aq] and \[aq]<right>\[aq])
jump-next                (default \[aq]]\[aq])
jump-prev                (default \[aq][\[aq])
top                      (default \[aq]gg\[aq] and \[aq]<home>\[aq])
bottom                   (default \[aq]G\[aq] and \[aq]<end>\[aq])
high                     (default \[aq]H\[aq])
middle                   (default \[aq]M\[aq])
low                      (default \[aq]L\[aq])
toggle
invert                   (default \[aq]v\[aq])
invert-below
unselect                 (default \[aq]u\[aq])
glob-select
glob-unselect
calcdirsize
clearmaps
copy                     (default \[aq]y\[aq])
cut                      (default \[aq]d\[aq])
paste                    (default \[aq]p\[aq])
clear                    (default \[aq]c\[aq])
sync
draw
redraw                   (default \[aq]<c-l>\[aq])
load
reload                   (default \[aq]<c-r>\[aq])
echo
echomsg
echoerr
cd
select
delete         (modal)
rename         (modal)   (default \[aq]r\[aq])
source
push
read           (modal)   (default \[aq]:\[aq])
shell          (modal)   (default \[aq]$\[aq])
shell-pipe     (modal)   (default \[aq]%\[aq])
shell-wait     (modal)   (default \[aq]!\[aq])
shell-async    (modal)   (default \[aq]&\[aq])
find           (modal)   (default \[aq]f\[aq])
find-back      (modal)   (default \[aq]F\[aq])
find-next                (default \[aq];\[aq])
find-prev                (default \[aq],\[aq])
search         (modal)   (default \[aq]/\[aq])
search-back    (modal)   (default \[aq]?\[aq])
search-next              (default \[aq]n\[aq])
search-prev              (default \[aq]N\[aq])
filter         (modal)
setfilter
mark-save      (modal)   (default \[aq]m\[aq])
mark-load      (modal)   (default \[dq]\[aq]\[dq])
mark-remove    (modal)   (default \[aq]\[dq]\[aq])
tag
tag-toggle               (default \[aq]t\[aq])
\f[R]
.fi
.PP
The following command line commands are provided by lf:
.IP
.nf
\f[C]
cmd-escape               (default \[aq]<esc>\[aq])
cmd-complete             (default \[aq]<tab>\[aq])
cmd-menu-complete
cmd-menu-complete-back
cmd-menu-accept
cmd-enter                (default \[aq]<c-j>\[aq] and \[aq]<enter>\[aq])
cmd-interrupt            (default \[aq]<c-c>\[aq])
cmd-history-next         (default \[aq]<c-n>\[aq] and \[aq]<down>\[aq])
cmd-history-prev         (default \[aq]<c-p>\[aq] and \[aq]<up>\[aq])
cmd-left                 (default \[aq]<c-b>\[aq] and \[aq]<left>\[aq])
cmd-right                (default \[aq]<c-f>\[aq] and \[aq]<right>\[aq])
cmd-home                 (default \[aq]<c-a>\[aq] and \[aq]<home>\[aq])
cmd-end                  (default \[aq]<c-e>\[aq] and \[aq]<end>\[aq])
cmd-delete               (default \[aq]<c-d>\[aq] and \[aq]<delete>\[aq])
cmd-delete-back          (default \[aq]<backspace>\[aq] and \[aq]<backspace2>\[aq])
cmd-delete-home          (default \[aq]<c-u>\[aq])
cmd-delete-end           (default \[aq]<c-k>\[aq])
cmd-delete-unix-word     (default \[aq]<c-w>\[aq])
cmd-yank                 (default \[aq]<c-y>\[aq])
cmd-transpose            (default \[aq]<c-t>\[aq])
cmd-transpose-word       (default \[aq]<a-t>\[aq])
cmd-word                 (default \[aq]<a-f>\[aq])
cmd-word-back            (default \[aq]<a-b>\[aq])
cmd-delete-word          (default \[aq]<a-d>\[aq])
cmd-delete-word-back     (default \[aq]<a-backspace>\[aq] and \[aq]<a-backspace2>\[aq])
cmd-capitalize-word      (default \[aq]<a-c>\[aq])
cmd-uppercase-word       (default \[aq]<a-u>\[aq])
cmd-lowercase-word       (default \[aq]<a-l>\[aq])
\f[R]
.fi
.PP
The following options can be used to customize the behavior of lf:
.IP
.nf
\f[C]
anchorfind        bool      (default true)
autoquit          bool      (default false)
borderfmt         string    (default \[dq]\[rs]033[0m\[dq])
cleaner           string    (default \[aq]\[aq])
copyfmt           string    (default \[dq]\[rs]033[7;33m\[dq])
cursoractivefmt   string    (default \[dq]\[rs]033[7m\[dq])
cursorparentfmt   string    (default \[dq]\[rs]033[7m\[dq])
cursorpreviewfmt  string    (default \[dq]\[rs]033[4m\[dq])
cutfmt            string    (default \[dq]\[rs]033[7;31m\[dq])
dircache          bool      (default true)
dircounts         bool      (default false)
dirfirst          bool      (default true)
dironly           bool      (default false)
dirpreviews       bool      (default false)
drawbox           bool      (default false)
dupfilefmt        string    (default \[aq]%f.\[ti]%n\[ti]\[aq])
errorfmt          string    (default \[dq]\[rs]033[7;31;47m\[dq])
filesep           string    (default \[dq]\[rs]n\[dq])
findlen           int       (default 1)
globfilter        bool      (default false)
globsearch        bool      (default false)
hidden            bool      (default false)
hiddenfiles       []string  (default \[aq].*\[aq] for Unix and \[aq]\[aq] for Windows)
history           bool      (default true)
icons             bool      (default false)
ifs               string    (default \[aq]\[aq])
ignorecase        bool      (default true)
ignoredia         bool      (default true)
incfilter         bool      (default false)
incsearch         bool      (default false)
info              []string  (default \[aq]\[aq])
infotimefmtnew    string    (default \[aq]Jan _2 15:04\[aq])
infotimefmtold    string    (default \[aq]Jan _2  2006\[aq])
mouse             bool      (default false)
number            bool      (default false)
numberfmt         string    (default \[dq]\[rs]033[33m\[dq])
period            int       (default 0)
preserve          []string  (default \[dq]mode\[dq])
preview           bool      (default true)
previewer         string    (default \[aq]\[aq])
promptfmt         string    (default \[dq]\[rs]033[32;1m%u\[at]%h\[rs]033[0m:\[rs]033[34;1m%d\[rs]033[0m\[rs]033[1m%f\[rs]033[0m\[dq])
ratios            []int     (default \[aq]1:2:3\[aq])
relativenumber    bool      (default false)
reverse           bool      (default false)
roundbox          bool      (default false)
rulerfmt          string    (default \[dq]  %a|  %p|  \[rs]033[7;31m %m \[rs]033[0m|  \[rs]033[7;33m %c \[rs]033[0m|  \[rs]033[7;35m %s \[rs]033[0m|  \[rs]033[7;34m %f \[rs]033[0m|  %i/%t\[dq])
scrolloff         int       (default 0)
selectfmt         string    (default \[dq]\[rs]033[7;35m\[dq])
selmode           string    (default \[aq]all\[aq])
shell             string    (default \[aq]sh\[aq] for Unix and \[aq]cmd\[aq] for Windows)
shellflag         string    (default \[aq]-c\[aq] for Unix and \[aq]/c\[aq] for Windows)
shellopts         []string  (default \[aq]\[aq])
sixel             bool      (default false)
smartcase         bool      (default true)
smartdia          bool      (default false)
sortby            string    (default \[aq]natural\[aq])
statfmt           string    (default \[dq]\[rs]033[36m%p\[rs]033[0m| %c| %u| %g| %S| %t| -> %l\[dq])
tabstop           int       (default 8)
tagfmt            string    (default \[dq]\[rs]033[31m\[dq])
tempmarks         string    (default \[aq]\[aq])
timefmt           string    (default \[aq]Mon Jan _2 15:04:05 2006\[aq])
truncatechar      string    (default \[aq]\[ti]\[aq])
truncatepct       int       (default 100)
waitmsg           string    (default \[aq]Press any key to continue\[aq])
watch             bool      (default false)
wrapscan          bool      (default true)
wrapscroll        bool      (default false)
user_{option}     string    (default none)
\f[R]
.fi
.PP
The following environment variables are exported for shell commands:
.IP
.nf
\f[C]
f
fs
fx
id
PWD
OLDPWD
LF_LEVEL
OPENER
VISUAL
EDITOR
PAGER
SHELL
lf
lf_{option}
lf_user_{option}
lf_width
lf_height
lf_count
lf_mode
\f[R]
.fi
.PP
The following special shell commands are used to customize the behavior
of lf when defined:
.IP
.nf
\f[C]
open
paste
rename
delete
pre-cd
on-cd
on-focus-gained
on-focus-lost
on-select
on-redraw
on-quit
\f[R]
.fi
.PP
The following commands/keybindings are provided by default:
.IP
.nf
\f[C]
Unix
cmd open &$OPENER \[dq]$f\[dq]
map e $$EDITOR \[dq]$f\[dq]
map i $$PAGER \[dq]$f\[dq]
map w $$SHELL
cmd doc $$lf -doc | $PAGER
map <f-1> doc
cmd maps $lf -remote \[dq]query $id maps\[dq] | $PAGER
cmd cmaps $lf -remote \[dq]query $id cmaps\[dq] | $PAGER
cmd cmds $lf -remote \[dq]query $id cmds\[dq] | $PAGER

Windows
cmd open &%OPENER% %f%
map e $%EDITOR% %f%
map i !%PAGER% %f%
map w $%SHELL%
cmd doc !%lf% -doc | %PAGER%
map <f-1> doc
cmd maps !%lf% -remote \[dq]query %id% maps\[dq] | %PAGER%
cmd cmaps !%lf% -remote \[dq]query %id% cmaps\[dq] | %PAGER%
cmd cmds !%lf% -remote \[dq]query %id% cmds\[dq] | %PAGER%
\f[R]
.fi
.PP
The following additional keybindings are provided by default:
.IP
.nf
\f[C]
map zh set hidden!
map zr set reverse!
map zn set info
map zs set info size
map zt set info time
map za set info size:time
map sn :set sortby natural; set info
map ss :set sortby size; set info size
map st :set sortby time; set info time
map sa :set sortby atime; set info atime
map sc :set sortby ctime; set info ctime
map se :set sortby ext; set info
map gh cd \[ti]
map <space> :toggle; down
\f[R]
.fi
.PP
If the \f[C]mouse\f[R] option is enabled, mouse buttons have the
following default effects:
.IP
.nf
\f[C]
Left mouse button
    Click on a file or directory to select it.

Right mouse button
    Enter a directory or open a file. Also works on the preview window.

Scroll wheel
    Move up or down. If Ctrl is pressed, scroll up or down.
\f[R]
.fi
.SH CONFIGURATION
.PP
Configuration files should be located at:
.IP
.nf
\f[C]
OS       system-wide               user-specific
Unix     /etc/lf/lfrc              \[ti]/.config/lf/lfrc
Windows  C:\[rs]ProgramData\[rs]lf\[rs]lfrc    C:\[rs]Users\[rs]<user>\[rs]AppData\[rs]Local\[rs]lf\[rs]lfrc
\f[R]
.fi
.PP
The colors file should be located at:
.IP
.nf
\f[C]
OS       system-wide               user-specific
Unix     /etc/lf/colors            \[ti]/.config/lf/colors
Windows  C:\[rs]ProgramData\[rs]lf\[rs]colors  C:\[rs]Users\[rs]<user>\[rs]AppData\[rs]Local\[rs]lf\[rs]colors
\f[R]
.fi
.PP
The icons file should be located at:
.IP
.nf
\f[C]
OS       system-wide               user-specific
Unix     /etc/lf/icons             \[ti]/.config/lf/icons
Windows  C:\[rs]ProgramData\[rs]lf\[rs]icons   C:\[rs]Users\[rs]<user>\[rs]AppData\[rs]Local\[rs]lf\[rs]icons
\f[R]
.fi
.PP
The selection file should be located at:
.IP
.nf
\f[C]
Unix     \[ti]/.local/share/lf/files
Windows  C:\[rs]Users\[rs]<user>\[rs]AppData\[rs]Local\[rs]lf\[rs]files
\f[R]
.fi
.PP
The marks file should be located at:
.IP
.nf
\f[C]
Unix     \[ti]/.local/share/lf/marks
Windows  C:\[rs]Users\[rs]<user>\[rs]AppData\[rs]Local\[rs]lf\[rs]marks
\f[R]
.fi
.PP
The tags file should be located at:
.IP
.nf
\f[C]
Unix     \[ti]/.local/share/lf/tags
Windows  C:\[rs]Users\[rs]<user>\[rs]AppData\[rs]Local\[rs]lf\[rs]tags
\f[R]
.fi
.PP
The history file should be located at:
.IP
.nf
\f[C]
Unix     \[ti]/.local/share/lf/history
Windows  C:\[rs]Users\[rs]<user>\[rs]AppData\[rs]Local\[rs]lf\[rs]history
\f[R]
.fi
.PP
You can configure these locations with the following variables given
with their order of precedences and their default values:
.IP
.nf
\f[C]
Unix
    $LF_CONFIG_HOME
    $XDG_CONFIG_HOME
    \[ti]/.config

    $LF_DATA_HOME
    $XDG_DATA_HOME
    \[ti]/.local/share

Windows
    %ProgramData%
    C:\[rs]ProgramData

    %LF_CONFIG_HOME%
    %LOCALAPPDATA%
    C:\[rs]Users\[rs]<user>\[rs]AppData\[rs]Local
\f[R]
.fi
.PP
A sample configuration file can be found at
<https://github.com/gokcehan/lf/blob/master/etc/lfrc.example>
.SH COMMANDS
.PP
This section shows information about built-in commands.
Modal commands do not take any arguments, but instead change the
operation mode to read their input conveniently, and so they are meant
to be assigned to keybindings.
.SS quit (default \f[C]q\f[R])
.PP
Quit lf and return to the shell.
.SS up (default \f[C]k\f[R] and \f[C]<up>\f[R]), half-up (default \f[C]<c-u>\f[R]), page-up (default \f[C]<c-b>\f[R] and \f[C]<pgup>\f[R]), scroll-up (default \f[C]<c-y>\f[R]), down (default \f[C]j\f[R] and \f[C]<down>\f[R]), half-down (default \f[C]<c-d>\f[R]), page-down (default \f[C]<c-f>\f[R] and \f[C]<pgdn>\f[R]), scroll-down (default \f[C]<c-e>\f[R])
.PP
Move/scroll the current file selection upwards/downwards by one/half a
page/full page.
.SS updir (default \f[C]h\f[R] and \f[C]<left>\f[R])
.PP
Change the current working directory to the parent directory.
.SS open (default \f[C]l\f[R] and \f[C]<right>\f[R])
.PP
If the current file is a directory, then change the current directory to
it, otherwise, execute the \f[C]open\f[R] command.
A default \f[C]open\f[R] command is provided to call the default system
opener asynchronously with the current file as the argument.
A custom \f[C]open\f[R] command can be defined to override this default.
.SS jump-next (default \f[C]]\f[R]), jump-prev (default \f[C][\f[R])
.PP
Change the current working directory to the next/previous jumplist item.
.SS top (default \f[C]gg\f[R] and \f[C]<home>\f[R]), bottom (default \f[C]G\f[R] and \f[C]<end>\f[R])
.PP
Move the current file selection to the top/bottom of the directory.
A count can be specified to move to a specific line, for example, use
\f[C]3G\f[R] to move to the third line.
.SS high (default \f[C]H\f[R]), middle (default \f[C]M\f[R]), low (default \f[C]L\f[R])
.PP
Move the current file selection to the high/middle/low of the screen.
.SS toggle
.PP
Toggle the selection of the current file or files given as arguments.
.SS invert (default \f[C]v\f[R])
.PP
Reverse the selection of all files in the current directory (i.e.
\f[C]toggle\f[R] all files).
Selections in other directories are not affected by this command.
You can define a new command to select all files in the directory by
combining \f[C]invert\f[R] with \f[C]unselect\f[R] (i.e.
\f[C]cmd select-all :unselect; invert\f[R]), though this will also
remove selections in other directories.
.SS invert-below
.PP
Reverse the selection (i.e.
\f[C]toggle\f[R]) of all files at or after the current file in the
current directory.
.PP
To select a contiguous block of files, use this command on the first
file you want to select.
Then, move down to the first file you do \f[I]not\f[R] want to select
(the one after the end of the desired selection) and use this command
again.
This achieves an effect similar to the visual mode in Vim.
.PP
This command is experimental and may be removed once a better
replacement for the visual mode is implemented in \f[C]lf\f[R].
If you\[aq]d like to experiment with using this command, you should bind
it to a key (e.g.
\f[C]V\f[R]) for a better experience.
.SS unselect (default \f[C]u\f[R])
.PP
Remove the selection of all files in all directories.
.SS glob-select, glob-unselect
.PP
Select/unselect files that match the given glob.
.SS calcdirsize
.PP
Calculate the total size for each of the selected directories.
Option \f[C]info\f[R] should include \f[C]size\f[R] and option
\f[C]dircounts\f[R] should be disabled to show this size.
If the total size of a directory is not calculated, it will be shown as
\f[C]-\f[R].
.SS clearmaps
.PP
Remove all keybindings associated with the \f[C]map\f[R] command.
This command can be used in the config file to remove the default
keybindings.
For safety purposes, \f[C]:\f[R] is left mapped to the \f[C]read\f[R]
command, and \f[C]cmap\f[R] keybindings are retained so that it is still
possible to exit \f[C]lf\f[R] using \f[C]:quit\f[R].
.SS copy (default \f[C]y\f[R])
.PP
If there are no selections, save the path of the current file to the
copy buffer, otherwise, copy the paths of selected files.
.SS cut (default \f[C]d\f[R])
.PP
If there are no selections, save the path of the current file to the cut
buffer, otherwise, copy the paths of selected files.
.SS paste (default \f[C]p\f[R])
.PP
Copy/Move files in the copy/cut buffer to the current working directory.
A custom \f[C]paste\f[R] command can be defined to override this
default.
.SS clear (default \f[C]c\f[R])
.PP
Clear file paths in copy/cut buffer.
.SS sync
.PP
Synchronize copied/cut files with the server.
This command is automatically called when required.
.SS draw
.PP
Draw the screen.
This command is automatically called when required.
.SS redraw (default \f[C]<c-l>\f[R])
.PP
Synchronize the terminal and redraw the screen.
.SS load
.PP
Load modified files and directories.
This command is automatically called when required.
.SS reload (default \f[C]<c-r>\f[R])
.PP
Flush the cache and reload all files and directories.
.SS echo
.PP
Print the given arguments to the message line at the bottom.
.SS echomsg
.PP
Print the given arguments to the message line at the bottom and also to
the log file.
.SS echoerr
.PP
Print given arguments to the message line at the bottom as
\f[C]errorfmt\f[R] and also to the log file.
.SS cd
.PP
Change the working directory to the given argument.
.SS select
.PP
Change the current file selection to the given argument.
.SS delete (modal)
.PP
Remove the current file or selected file(s).
A custom \f[C]delete\f[R] command can be defined to override this
default.
.SS rename (modal) (default \f[C]r\f[R])
.PP
Rename the current file using the built-in method.
A custom \f[C]rename\f[R] command can be defined to override this
default.
.SS source
.PP
Read the configuration file given in the argument.
.SS push
.PP
Simulate key pushes given in the argument.
.SS read (modal) (default \f[C]:\f[R])
.PP
Read a command to evaluate.
.SS shell (modal) (default \f[C]$\f[R])
.PP
Read a shell command to execute.
.SS shell-pipe (modal) (default \f[C]%\f[R])
.PP
Read a shell command to execute piping its standard I/O to the bottom
statline.
.SS shell-wait (modal) (default \f[C]!\f[R])
.PP
Read a shell command to execute and wait for a key press in the end.
.SS shell-async (modal) (default \f[C]&\f[R])
.PP
Read a shell command to execute asynchronously without standard I/O.
.SS find (modal) (default \f[C]f\f[R]), find-back (modal) (default \f[C]F\f[R]), find-next (default \f[C];\f[R]), find-prev (default \f[C],\f[R])
.PP
Read key(s) to find the appropriate file name match in the
forward/backward direction and jump to the next/previous match.
.SS search (default \f[C]/\f[R]), search-back (default \f[C]?\f[R]), search-next (default \f[C]n\f[R]), search-prev (default \f[C]N\f[R])
.PP
Read a pattern to search for a file name match in the forward/backward
direction and jump to the next/previous match.
.SS filter (modal), setfilter
.PP
Command \f[C]filter\f[R] reads a pattern to filter out and only view
files matching the pattern.
Command \f[C]setfilter\f[R] does the same but uses an argument to set
the filter immediately.
You can supply an argument to \f[C]filter\f[R] to use as the starting
prompt.
.SS mark-save (modal) (default \f[C]m\f[R])
.PP
Save the current directory as a bookmark assigned to the given key.
.SS mark-load (modal) (default \f[C]\[aq]\f[R])
.PP
Change the current directory to the bookmark assigned to the given key.
A special bookmark \f[C]\[aq]\f[R] holds the previous directory after a
\f[C]mark-load\f[R], \f[C]cd\f[R], or \f[C]select\f[R] command.
.SS mark-remove (modal) (default \f[C]\[dq]\f[R])
.PP
Remove a bookmark assigned to the given key.
.SS tag
.PP
Tag a file with \f[C]*\f[R] or a single-width character given in the
argument.
You can define a new tag-clearing command by combining \f[C]tag\f[R]
with \f[C]tag-toggle\f[R] (i.e.
\f[C]cmd tag-clear :tag; tag-toggle\f[R]).
.SS tag-toggle (default \f[C]t\f[R])
.PP
Tag a file with \f[C]*\f[R] or a single width character given in the
argument if the file is untagged, otherwise remove the tag.
.SH COMMAND LINE COMMANDS
.PP
The prompt character specifies which of the several command-line modes
you are in.
For example, the \f[C]read\f[R] command takes you to the \f[C]:\f[R]
mode.
.PP
When the cursor is at the first character in \f[C]:\f[R] mode, pressing
one of the keys \f[C]!\f[R], \f[C]$\f[R], \f[C]%\f[R], or \f[C]&\f[R]
takes you to the corresponding mode.
You can go back with \f[C]cmd-delete-back\f[R] (\f[C]<backspace>\f[R] by
default).
.PP
The command line commands should be mostly compatible with readline
keybindings.
A character refers to a Unicode code point, a word consists of letters
and digits, and a unix word consists of any non-blank characters.
.SS cmd-escape (default \f[C]<esc>\f[R])
.PP
Quit command line mode and return to normal mode.
.SS cmd-complete (default \f[C]<tab>\f[R])
.PP
Autocomplete the current word.
.SS cmd-menu-complete, cmd-menu-complete-back
.PP
Autocomplete the current word with the menu selection.
You need to assign keys to these commands (e.g.
\f[C]cmap <tab> cmd-menu-complete; cmap <backtab> cmd-menu-complete-back\f[R]).
You can use the assigned keys to display the menu and then cycle through
completion options.
.SS cmd-menu-accept
.PP
Accept the currently selected match in menu completion and close the
menu.
.SS cmd-enter (default \f[C]<c-j>\f[R] and \f[C]<enter>\f[R])
.PP
Execute the current line.
.SS cmd-interrupt (default \f[C]<c-c>\f[R])
.PP
Interrupt the current shell-pipe command and return to the normal mode.
.SS cmd-history-next (default \f[C]<c-n>\f[R] and \f[C]<down>\f[R]), cmd-history-prev (default \f[C]<c-p>\f[R] and \f[C]<up>\f[R])
.PP
Go to the next/previous item in the history.
.SS cmd-left (default \f[C]<c-b>\f[R] and \f[C]<left>\f[R]), cmd-right (default \f[C]<c-f>\f[R] and \f[C]<right>\f[R])
.PP
Move the cursor to the left/right.
.SS cmd-home (default \f[C]<c-a>\f[R] and \f[C]<home>\f[R]), cmd-end (default \f[C]<c-e>\f[R] and \f[C]<end>\f[R])
.PP
Move the cursor to the beginning/end of the line.
.SS cmd-delete (default \f[C]<c-d>\f[R] and \f[C]<delete>\f[R])
.PP
Delete the next character.
.SS cmd-delete-back (default \f[C]<backspace>\f[R] and \f[C]<backspace2>\f[R])
.PP
Delete the previous character.
When at the beginning of a prompt, returns either to normal mode or to
\f[C]:\f[R] mode.
.SS cmd-delete-home (default \f[C]<c-u>\f[R]), cmd-delete-end (default \f[C]<c-k>\f[R])
.PP
Delete everything up to the beginning/end of the line.
.SS cmd-delete-unix-word (default \f[C]<c-w>\f[R])
.PP
Delete the previous unix word.
.SS cmd-yank (default \f[C]<c-y>\f[R])
.PP
Paste the buffer content containing the last deleted item.
.SS cmd-transpose (default \f[C]<c-t>\f[R]), cmd-transpose-word (default \f[C]<a-t>\f[R])
.PP
Transpose the positions of the last two characters/words.
.SS cmd-word (default \f[C]<a-f>\f[R]), cmd-word-back (default \f[C]<a-b>\f[R])
.PP
Move the cursor by one word in the forward/backward direction.
.SS cmd-delete-word (default \f[C]<a-d>\f[R])
.PP
Delete the next word in the forward direction.
.SS cmd-delete-word-back (default \f[C]<a-backspace>\f[R] and \f[C]<a-backspace2>\f[R])
.PP
Delete the previous word in the backward direction.
.SS cmd-capitalize-word (default \f[C]<a-c>\f[R]), cmd-uppercase-word (default \f[C]<a-u>\f[R]), cmd-lowercase-word (default \f[C]<a-l>\f[R])
.PP
Capitalize/uppercase/lowercase the current word and jump to the next
word.
.SH OPTIONS
.PP
This section shows information about options to customize the behavior.
Character \f[C]:\f[R] is used as the separator for list options
\f[C][]int\f[R] and \f[C][]string\f[R].
.SS anchorfind (bool) (default true)
.PP
When this option is enabled, the find command starts matching patterns
from the beginning of file names, otherwise, it can match at an
arbitrary position.
.SS autoquit (bool) (default false)
.PP
Automatically quit the server when there are no clients left connected.
.SS borderfmt (string) (default \f[C]\[rs]033[0m\f[R])
.PP
Format string of the box drawing characters enabled by the
\f[C]drawbox\f[R] option.
.SS cleaner (string) (default \[ga]\[ga]) (not called if empty)
.PP
Set the path of a cleaner file.
The file should be executable.
This file is called if previewing is enabled, the previewer is set, and
the previously selected file has its preview cache disabled.
The following arguments are passed to the file, (1) current file name,
(2) width, (3) height, (4) horizontal position, (5) vertical position of
preview pane and (6) next file name to be previewed respectively.
Preview cleaning is disabled when the value of this option is left
empty.
.SS copyfmt (string) (default \f[C]\[rs]033[7;33m\f[R])
.PP
Format string of the indicator for files to be copied.
.SS cursoractivefmt (string) (default \f[C]\[rs]033[7m\f[R]), cursorparentfmt string (default \f[C]\[rs]033[7m\f[R]), cursorpreviewfmt string (default \f[C]\[rs]033[4m\f[R])
.PP
Format strings for highlighting the cursor.
\f[C]cursoractivefmt\f[R] applies in the current directory pane,
\f[C]cursorparentfmt\f[R] applies in panes that show parents of the
current directory, and \f[C]cursorpreviewfmt\f[R] applies in panes that
preview directories.
.PP
The default is to make the active cursor and the parent directory cursor
inverted.
The preview cursor is underlined.
.PP
Some other possibilities to consider for the preview or parent cursors:
an empty string for no cursor, \f[C]\[rs]033[7;2m\f[R] for dimmed
inverted text (visibility varies by terminal), \f[C]\[rs]033[7;90m\f[R]
for inverted text with grey (aka \[dq]brightblack\[dq]) background.
.PP
If the format string contains the characters \f[C]%s\f[R], it is
interpreted as a format string for \f[C]fmt.Sprintf\f[R].
Such a string should end with the terminal reset sequence.
For example, \f[C]\[rs]033[4m%s\[rs]033[0m\f[R] has the same effect as
\f[C]\[rs]033[4m\f[R].
.SS cutfmt (string) (default \f[C]\[rs]033[7;31m\f[R])
.PP
Format string of the indicator for files to be cut.
.SS dircache (bool) (default true)
.PP
Cache directory contents.
.SS dircounts (bool) (default false)
.PP
When this option is enabled, directory sizes show the number of items
inside instead of the total size of the directory, which needs to be
calculated for each directory using \f[C]calcdirsize\f[R].
This information needs to be calculated by reading the directory and
counting the items inside.
Therefore, this option is disabled by default for performance reasons.
This option only has an effect when \f[C]info\f[R] has a \f[C]size\f[R]
field and the pane is wide enough to show the information.
999 items are counted per directory at most, and bigger directories are
shown as \f[C]999+\f[R].
.SS dirfirst (bool) (default true)
.PP
Show directories first above regular files.
.SS dironly (bool) (default false)
.PP
Show only directories.
.SS dirpreviews (bool) (default false)
.PP
If enabled, directories will also be passed to the previewer script.
This allows custom previews for directories.
.SS drawbox (bool) (default false)
.PP
Draw boxes around panes with box drawing characters.
.SS dupfilefmt (string) (default \f[C]%f.\[ti]%n\[ti]\f[R])
.PP
Format string of file name when creating duplicate files.
With the default format, copying a file \f[C]abc.txt\f[R] to the same
directory will result in a duplicate file called
\f[C]abc.txt.\[ti]1\[ti]\f[R].
Special expansions are provided, \f[C]%f\f[R] as the file name,
\f[C]%b\f[R] for the basename (file name without extension),
\f[C]%e\f[R] as the extension (including the dot) and \f[C]%n\f[R] as
the number of duplicates.
.SS errorfmt (string) (default \f[C]\[rs]033[7;31;47m\f[R])
.PP
Format string of error messages shown in the bottom message line.
.PP
If the format string contains the characters \f[C]%s\f[R], it is
interpreted as a format string for \f[C]fmt.Sprintf\f[R].
Such a string should end with the terminal reset sequence.
For example, \f[C]\[rs]033[4m%s\[rs]033[0m\f[R] has the same effect as
\f[C]\[rs]033[4m\f[R].
.SS filesep (string) (default \f[C]\[rs]n\f[R])
.PP
File separator used in environment variables \f[C]fs\f[R] and
\f[C]fx\f[R].
.SS findlen (int) (default 1)
.PP
Number of characters prompted for the find command.
When this value is set to 0, find command prompts until there is only a
single match left.
.SS globfilter (bool) (default false)
.PP
Patterns are treated as globs for the filter command, see
\f[C]globsearch\f[R] for more details.
.SS globsearch (bool) (default false)
.PP
When this option is enabled, search command patterns are considered as
globs, otherwise, they are literals.
With globbing, \f[C]*\f[R] matches any sequence, \f[C]?\f[R] matches any
character, and \f[C][...]\f[R] or \f[C][\[ha]...]\f[R] matches character
sets or ranges.
Otherwise, these characters are interpreted as they are.
.SS hidden (bool) (default false)
.PP
Show hidden files.
On Unix systems, hidden files are determined by the value of
\f[C]hiddenfiles\f[R].
On Windows, files with hidden attributes are also considered hidden
files.
.SS hiddenfiles ([]string) (default \f[C].*\f[R] for Unix and \[ga]\[ga] for Windows)
.PP
List of hidden file glob patterns.
Patterns can be given as relative or absolute paths.
Globbing supports the usual special characters, \f[C]*\f[R] to match any
sequence, \f[C]?\f[R] to match any character, and \f[C][...]\f[R] or
\f[C][\[ha]...]\f[R] to match character sets or ranges.
In addition, if a pattern starts with \f[C]!\f[R], then its matches are
excluded from hidden files.
To add multiple patterns, use \f[C]:\f[R] as a separator.
Example: \f[C].*:lost+found:*.bak\f[R]
.SS history (bool) (default true)
.PP
Save command history.
.SS icons (bool) (default false)
.PP
Show icons before each item in the list.
.SS ifs (string) (default \[ga]\[ga])
.PP
Sets \f[C]IFS\f[R] variable in shell commands.
It works by adding the assignment to the beginning of the command string
as \f[C]IFS=...; ...\f[R].
The reason is that \f[C]IFS\f[R] variable is not inherited by the shell
for security reasons.
This method assumes a POSIX shell syntax so it can fail for non-POSIX
shells.
This option has no effect when the value is left empty.
This option does not have any effect on Windows.
.SS ignorecase (bool) (default true)
.PP
Ignore case in sorting and search patterns.
.SS ignoredia (bool) (default true)
.PP
Ignore diacritics in sorting and search patterns.
.SS incsearch (bool) (default false)
.PP
Jump to the first match after each keystroke during searching.
.SS incfilter (bool) (default false)
.PP
Apply filter pattern after each keystroke during filtering.
.SS info ([]string) (default \[ga]\[ga])
.PP
A list of information that is shown for directory items at the right
side of the pane.
Currently supported information types are \f[C]size\f[R],
\f[C]time\f[R], \f[C]atime\f[R], and \f[C]ctime\f[R].
Information is only shown when the pane width is more than twice the
width of information.
.SS infotimefmtnew (string) (default \f[C]Jan _2 15:04\f[R])
.PP
Format string of the file time shown in the info column when it matches
this year.
.SS infotimefmtold (string) (default \f[C]Jan _2  2006\f[R])
.PP
Format string of the file time shown in the info column when it
doesn\[aq]t match this year.
.SS mouse (bool) (default false)
.PP
Send mouse events as input.
.SS number (bool) (default false)
.PP
Show the position number for directory items on the left side of the
pane.
When the \f[C]relativenumber\f[R] option is enabled, only the current
line shows the absolute position and relative positions are shown for
the rest.
.SS numberfmt (string) (default \f[C]\[rs]033[33m\f[R])
.PP
Format string of the position number for each line.
.SS period (int) (default 0)
.PP
Set the interval in seconds for periodic checks of directory updates.
This works by periodically calling the \f[C]load\f[R] command.
Note that directories are already updated automatically in many cases.
This option can be useful when there is an external process changing the
displayed directory and you are not doing anything in lf.
Periodic checks are disabled when the value of this option is set to
zero.
.SS preserve ([]string) (default \f[C]mode\f[R])
.PP
List of attributes that are preserved when copying files.
Currently supported attributes are \f[C]mode\f[R] (i.a.
access mode) and \f[C]timestamps\f[R] (i.e.
modification time and access time).
Note that preserving other attributes like ownership of change/birth
timestamp is desirable, but not portably supported in Go.
.SS preview (bool) (default true)
.PP
Show previews of files and directories at the rightmost pane.
If the file has more lines than the preview pane, the rest of the lines
are not read.
Files containing the null character (U+0000) in the read portion are
considered binary files and displayed as \f[C]binary\f[R].
.SS previewer (string) (default \[ga]\[ga]) (not filtered if empty)
.PP
Set the path of a previewer file to filter the content of regular files
for previewing.
The file should be executable.
The following arguments are passed to the file, (1) current file name,
(2) width, (3) height, (4) horizontal position, and (5) vertical
position of preview pane respectively.
SIGPIPE signal is sent when enough lines are read.
If the previewer returns a non-zero exit code, then the preview cache
for the given file is disabled.
This means that if the file is selected in the future, the previewer is
called once again.
Preview filtering is disabled and files are displayed as they are when
the value of this option is left empty.
.SS promptfmt (string) (default \f[C]\[rs]033[32;1m%u\[at]%h\[rs]033[0m:\[rs]033[34;1m%d\[rs]033[0m\[rs]033[1m%f\[rs]033[0m\f[R])
.PP
Format string of the prompt shown in the top line.
Special expansions are provided, \f[C]%u\f[R] as the user name,
\f[C]%h\f[R] as the hostname, \f[C]%w\f[R] as the working directory,
\f[C]%d\f[R] as the working directory with a trailing path separator,
\f[C]%f\f[R] as the file name, and \f[C]%F\f[R] as the current filter.
\f[C]%S\f[R] may be used once and will provide a spacer so that the
following parts are right aligned on the screen.
The home folder is shown as \f[C]\[ti]\f[R] in the working directory
expansion.
Directory names are automatically shortened to a single character
starting from the leftmost parent when the prompt does not fit the
screen.
.SS ratios ([]int) (default \f[C]1:2:3\f[R])
.PP
List of ratios of pane widths.
Number of items in the list determines the number of panes in the UI.
When the \f[C]preview\f[R] option is enabled, the rightmost number is
used for the width of the preview pane.
.SS relativenumber (bool) (default false)
.PP
Show the position number relative to the current line.
When \f[C]number\f[R] is enabled, the current line shows the absolute
position, otherwise nothing is shown.
.SS reverse (bool) (default false)
.PP
Reverse the direction of sort.
.SS roundbox (bool) (default false)
.PP
Draw rounded outer corners when the \f[C]drawbox\f[R] option is enabled.
.SS rulerfmt (string) (default \f[C]  %a|  %p|  \[rs]033[7;31m %m \[rs]033[0m|  \[rs]033[7;33m %c \[rs]033[0m|  \[rs]033[7;35m %s \[rs]033[0m|  \[rs]033[7;34m %f \[rs]033[0m|  %i/%t\f[R])
.PP
Format string of the ruler shown in the bottom right corner.
Special expansions are provided, \f[C]%a\f[R] as the pressed keys,
\f[C]%p\f[R] as the progress of file operations, \f[C]%m\f[R] as the
number of files to be cut (moved), \f[C]%c\f[R] as the number of files
to be copied, \f[C]%s\f[R] as the number of selected files, \f[C]%f\f[R]
as the filter, \f[C]%i\f[R] as the position of the cursor, \f[C]%t\f[R]
as the number of files shown in the current directory, \f[C]%h\f[R] as
the number of files hidden in the current directory, and \f[C]%d\f[R] as
the amount of free disk space remaining.
Additional expansions are provided for environment variables exported by
lf, in the form \f[C]%{lf_<name>}\f[R] (e.g.
\f[C]%{lf_selmode}\f[R]).
This is useful for displaying the current settings.
Expansions are also provided for user-defined options, in the form
\f[C]%{lf_user_<name>}\f[R] (e.g.
\f[C]%{lf_user_foo}\f[R]).
The \f[C]|\f[R] character splits the format string into sections.
Any section containing a failed expansion (result is a blank string) is
discarded and not shown.
.SS selectfmt (string) (default \f[C]\[rs]033[7;35m\f[R])
.PP
Format string of the indicator for files that are selected.
.SS selmode (string) (default \f[C]all\f[R])
.PP
Selection mode for commands.
When set to \f[C]all\f[R] it will use the selected files from all
directories.
When set to \f[C]dir\f[R] it will only use the selected files in the
current directory.
.SS scrolloff (int) (default 0)
.PP
Minimum number of offset lines shown at all times at the top and bottom
of the screen when scrolling.
The current line is kept in the middle when this option is set to a
large value that is bigger than the half of number of lines.
A smaller offset can be used when the current file is close to the
beginning or end of the list to show the maximum number of items.
.SS shell (string) (default \f[C]sh\f[R] for Unix and \f[C]cmd\f[R] for Windows)
.PP
Shell executable to use for shell commands.
Shell commands are executed as
\f[C]shell shellopts shellflag command -- arguments\f[R].
.SS shellflag (string) (default \f[C]-c\f[R] for Unix and \f[C]/c\f[R] for Windows)
.PP
Command line flag used to pass shell commands.
.SS shellopts ([]string) (default \[ga]\[ga])
.PP
List of shell options to pass to the shell executable.
.SS sixel (bool) (default false)
.PP
Render sixel images in preview.
.SS smartcase (bool) (default true)
.PP
Override \f[C]ignorecase\f[R] option when the pattern contains an
uppercase character.
This option has no effect when \f[C]ignorecase\f[R] is disabled.
.SS smartdia (bool) (default false)
.PP
Override \f[C]ignoredia\f[R] option when the pattern contains a
character with diacritic.
This option has no effect when \f[C]ignoredia\f[R] is disabled.
.SS sortby (string) (default \f[C]natural\f[R])
.PP
Sort type for directories.
Currently supported sort types are \f[C]natural\f[R], \f[C]name\f[R],
\f[C]size\f[R], \f[C]time\f[R], \f[C]ctime\f[R], \f[C]atime\f[R], and
\f[C]ext\f[R].
.SS statfmt (string) (default \f[C]\[rs]033[36m%p\[rs]033[0m| %c| %u| %g| %S| %t| -> %l\f[R])
.PP
Format string of the file info shown in the bottom left corner.
Special expansions are provided, \f[C]%p\f[R] as the file permissions,
\f[C]%c\f[R] as the link count, \f[C]%u\f[R] as the user, \f[C]%g\f[R]
as the group, \f[C]%s\f[R] as the file size, \f[C]%S\f[R] as the file
size but with a fixed width of four characters (left-padded with
spaces), \f[C]%t\f[R] as the last modified time, and \f[C]%l\f[R] as the
link target.
The \f[C]|\f[R] character splits the format string into sections.
Any section containing a failed expansion (result is a blank string) is
discarded and not shown.
.SS tabstop (int) (default 8)
.PP
Number of space characters to show for horizontal tabulation (U+0009)
character.
.SS tagfmt (string) (default \f[C]\[rs]033[31m\f[R])
.PP
Format string of the tags.
.PP
If the format string contains the characters \f[C]%s\f[R], it is
interpreted as a format string for \f[C]fmt.Sprintf\f[R].
Such a string should end with the terminal reset sequence.
For example, \f[C]\[rs]033[4m%s\[rs]033[0m\f[R] has the same effect as
\f[C]\[rs]033[4m\f[R].
.SS tempmarks (string) (default \[ga]\[ga])
.PP
Marks to be considered temporary (e.g.
\f[C]abc\f[R] refers to marks \f[C]a\f[R], \f[C]b\f[R], and
\f[C]c\f[R]).
These marks are not synced to other clients and they are not saved in
the bookmarks file.
Note that the special bookmark \f[C]\[ga]\f[R] is always treated as
temporary and it does not need to be specified.
.SS timefmt (string) (default \f[C]Mon Jan _2 15:04:05 2006\f[R])
.PP
Format string of the file modification time shown in the bottom line.
.SS truncatechar (string) (default \f[C]\[ti]\f[R])
.PP
The truncate character that is shown at the end when the file name does
not fit into the pane.
.SS truncatepct (int) (default 100)
.PP
When a filename is too long to be shown completely, the available space
is partitioned into two pieces.
truncatepct defines a fraction (in percent between 0 and 100) for the
size of the first piece, which will show the beginning of the filename.
The second piece will show the end of the filename and will use the rest
of the available space.
Both pieces are separated by the truncation character (truncatechar).
A value of 100 will only show the beginning of the filename, while a
value of 0 will only show the end of the filename, e.g.:
.IP \[bu] 2
\f[C]set truncatepct 100\f[R] -> \f[C]very-long-filename-tr\[ti]\f[R]
(default)
.IP \[bu] 2
\f[C]set truncatepct 50\f[R] -> \f[C]very-long-f\[ti]-truncated\f[R]
.IP \[bu] 2
\f[C]set truncatepct 0\f[R] -> \f[C]\[ti]ng-filename-truncated\f[R]
.SS waitmsg (string) (default \f[C]Press any key to continue\f[R])
.PP
String shown after commands of shell-wait type.
.SS watch (bool) (default false)
.PP
Watch the filesystem for changes using \f[C]fsnotify\f[R] to
automatically refresh file information.
FUSE is currently not supported due to limitations in
\f[C]fsnotify\f[R].
.SS wrapscan (bool) (default true)
.PP
Searching can wrap around the file list.
.SS wrapscroll (bool) (default false)
.PP
Scrolling can wrap around the file list.
.SS user_{option} (string) (default none)
.PP
Any option that is prefixed with \f[C]user_\f[R] is a user-defined
option and can be set to any string.
Inside a user-defined command, the value will be provided in the
\f[C]lf_user_{option}\f[R] environment variable.
These options are not used by lf and are not persisted.
.SH ENVIRONMENT VARIABLES
.PP
The following variables are exported for shell commands: These are
referred to with a \f[C]$\f[R] prefix on POSIX shells (e.g.
\f[C]$f\f[R]), between \f[C]%\f[R] characters on Windows cmd (e.g.
\f[C]%f%\f[R]), and with a \f[C]$env:\f[R] prefix on Windows PowerShell
(e.g.
\f[C]$env:f\f[R]).
.SS f
.PP
Current file selection as a full path.
.SS fs
.PP
Selected file(s) separated with the value of \f[C]filesep\f[R] option as
full path(s).
.SS fx
.PP
Selected file(s) (i.e.
\f[C]fs\f[R]) if there are any selected files, otherwise current file
selection (i.e.
\f[C]f\f[R]).
.SS id
.PP
Id of the running client.
.SS PWD
.PP
Present working directory.
.SS OLDPWD
.PP
Initial working directory.
.SS LF_LEVEL
.PP
The value of this variable is set to the current nesting level when you
run lf from a shell spawned inside lf.
You can add the value of this variable to your shell prompt to make it
clear that your shell runs inside lf.
For example, with POSIX shells, you can use
\f[C][ -n \[dq]$LF_LEVEL\[dq] ] && PS1=\[dq]$PS1\[dq]\[dq](lf level: $LF_LEVEL) \[dq]\f[R]
in your shell configuration file (e.g.
\f[C]\[ti]/.bashrc\f[R]).
.SS OPENER
.PP
If this variable is set in the environment, use the same value.
Otherwise, this is set to \f[C]start\f[R] in Windows, \f[C]open\f[R] in
MacOS, \f[C]xdg-open\f[R] in others.
.SS EDITOR
.PP
If VISUAL is set in the environment, use its value.
Otherwise, use the value of the environment variable EDITOR.
If neither variable is set, this is set to \f[C]vi\f[R] on Unix,
\f[C]notepad\f[R] in Windows.
.SS PAGER
.PP
If this variable is set in the environment, use the same value.
Otherwise, this is set to \f[C]less\f[R] on Unix, \f[C]more\f[R] in
Windows.
.SS SHELL
.PP
If this variable is set in the environment, use the same value.
Otherwise, this is set to \f[C]sh\f[R] on Unix, \f[C]cmd\f[R] in
Windows.
.SS lf
.PP
Absolute path to the currently running lf binary, if it can be found.
Otherwise, this is set to the string \f[C]lf\f[R].
.SS lf_{option}
.PP
Value of the {option}.
.SS lf_user_{option}
.PP
Value of the user_{option}.
.SS lf_width, lf_height
.PP
Width/Height of the terminal.
.SS lf_count
.PP
Value of the count associated with the current command.
.SS lf_mode
.PP
Current mode that \f[C]lf\f[R] is operating in.
This is useful for customizing keybindings depending on what the current
mode is.
Possible values are \f[C]delete\f[R], \f[C]rename\f[R],
\f[C]filter\f[R], \f[C]find\f[R], \f[C]mark\f[R], \f[C]search\f[R],
\f[C]command\f[R], \f[C]shell\f[R], \f[C]pipe\f[R] (when running a
shell-pipe command), \f[C]normal\f[R], and \f[C]unknown\f[R].
.SH SPECIAL COMMANDS
.PP
This section shows information about special shell commands.
.SS open
.PP
This shell command can be defined to override the default \f[C]open\f[R]
command when the current file is not a directory.
.SS paste
.PP
This shell command can be defined to override the default
\f[C]paste\f[R] command.
.SS rename
.PP
This shell command can be defined to override the default
\f[C]rename\f[R] command.
.SS delete
.PP
This shell command can be defined to override the default
\f[C]delete\f[R] command.
.SS pre-cd
.PP
This shell command can be defined to be executed before changing a
directory.
.SS on-cd
.PP
This shell command can be defined to be executed after changing a
directory.
.SS on-focus-gained
.PP
This shell command can be defined to be executed when the terminal gains
focus.
.SS on-focus-lost
.PP
This shell command can be defined to be executed when the terminal loses
focus.
.SS on-select
.PP
This shell command can be defined to be executed after the selection
changes.
.SS on-redraw
.PP
This shell command can be defined to be executed after the screen is
redrawn or if the terminal is resized.
.SS on-quit
.PP
This shell command can be defined to be executed before quitting.
.SH PREFIXES
.PP
The following command prefixes are used by lf:
.IP
.nf
\f[C]
:  read (default)  builtin/custom command
$  shell           shell command
%  shell-pipe      shell command running with the UI
!  shell-wait      shell command waiting for a key press
&  shell-async     shell command running asynchronously
\f[R]
.fi
.PP
The same evaluator is used for the command line and the configuration
file for reading shell commands.
The difference is that prefixes are not necessary in the command line.
Instead, different modes are provided to read corresponding commands.
These modes are mapped to the prefix keys above by default.
.SH SYNTAX
.PP
Characters from \f[C]#\f[R] to newline are comments and ignored:
.IP
.nf
\f[C]
# comments start with \[ga]#\[ga]
\f[R]
.fi
.PP
There are five special commands (\f[C]set\f[R], \f[C]setlocal\f[R],
\f[C]map\f[R], \f[C]cmap\f[R], and \f[C]cmd\f[R]) for configuration.
.PP
Command \f[C]set\f[R] is used to set an option which can be a boolean,
integer, or string:
.IP
.nf
\f[C]
set hidden         # boolean enable
set hidden true    # boolean enable
set nohidden       # boolean disable
set hidden false   # boolean disable
set hidden!        # boolean toggle
set scrolloff 10   # integer value
set sortby time    # string value w/o quotes
set sortby \[aq]time\[aq]  # string value with single quotes (whitespaces)
set sortby \[dq]time\[dq]  # string value with double quotes (backslash escapes)
\f[R]
.fi
.PP
Command \f[C]setlocal\f[R] is used to set a local option for a directory
which can be a boolean or string.
Currently supported local options are \f[C]dirfirst\f[R],
\f[C]dironly\f[R], \f[C]hidden\f[R], \f[C]info\f[R], \f[C]reverse\f[R],
and \f[C]sortby\f[R].
Adding a trailing path separator (i.e.
\f[C]/\f[R] for Unix and \f[C]\[rs]\f[R] for Windows) sets the option
for the given directory along with its subdirectories:
.IP
.nf
\f[C]
setlocal /foo/bar hidden         # boolean enable
setlocal /foo/bar hidden true    # boolean enable
setlocal /foo/bar nohidden       # boolean disable
setlocal /foo/bar hidden false   # boolean disable
setlocal /foo/bar hidden!        # boolean toggle
setlocal /foo/bar sortby time    # string value w/o quotes
setlocal /foo/bar sortby \[aq]time\[aq]  # string value with single quotes (whitespaces)
setlocal /foo/bar sortby \[dq]time\[dq]  # string value with double quotes (backslash escapes)
setlocal /foo/bar  hidden        # for only \[aq]/foo/bar\[aq] directory
setlocal /foo/bar/ hidden        # for \[aq]/foo/bar\[aq] and its subdirectories (e.g. \[aq]/foo/bar/baz\[aq])
\f[R]
.fi
.PP
Command \[aq]map\[aq] is used to bind a key to a command which can be a
builtin command, custom command, or shell command:
.IP
.nf
\f[C]
map gh cd \[ti]        # builtin command
map D trash        # custom command
map i $less $f     # shell command
map U !du -csh *   # waiting shell command
\f[R]
.fi
.PP
Command \[aq]cmap\[aq] is used to bind a key on the command line to a
command line command or any other command:
.IP
.nf
\f[C]
cmap <c-g> cmd-escape
cmap <a-i> set incsearch!
\f[R]
.fi
.PP
You can delete an existing binding by leaving the expression empty:
.IP
.nf
\f[C]
map gh             # deletes \[aq]gh\[aq] mapping
cmap <c-g>         # deletes \[aq]<c-g>\[aq] mapping
\f[R]
.fi
.PP
Command \f[C]cmd\f[R] is used to define a custom command:
.IP
.nf
\f[C]
cmd usage $du -h -d1 | less
\f[R]
.fi
.PP
You can delete an existing command by leaving the expression empty:
.IP
.nf
\f[C]
cmd trash          # deletes \[aq]trash\[aq] command
\f[R]
.fi
.PP
If there is no prefix then \f[C]:\f[R] is assumed:
.IP
.nf
\f[C]
map zt set info time
\f[R]
.fi
.PP
An explicit \f[C]:\f[R] can be provided to group statements until a
newline which is especially useful for \f[C]map\f[R] and \f[C]cmd\f[R]
commands:
.IP
.nf
\f[C]
map st :set sortby time; set info time
\f[R]
.fi
.PP
If you need multiline you can wrap statements in \f[C]{{\f[R] and
\f[C]}}\f[R] after the proper prefix.
.IP
.nf
\f[C]
map st :{{
    set sortby time
    set info time
}}
\f[R]
.fi
.SH KEY MAPPINGS
.PP
Regular keys are assigned to a command with the usual syntax:
.IP
.nf
\f[C]
map a down
\f[R]
.fi
.PP
Keys combined with the shift key simply use the uppercase letter:
.IP
.nf
\f[C]
map A down
\f[R]
.fi
.PP
Special keys are written in between \f[C]<\f[R] and \f[C]>\f[R]
characters and always use lowercase letters:
.IP
.nf
\f[C]
map <enter> down
\f[R]
.fi
.PP
Angle brackets can be assigned with their special names:
.IP
.nf
\f[C]
map <lt> down
map <gt> down
\f[R]
.fi
.PP
Function keys are prefixed with \f[C]f\f[R] character:
.IP
.nf
\f[C]
map <f-1> down
\f[R]
.fi
.PP
Keys combined with the control key are prefixed with a \f[C]c\f[R]
character:
.IP
.nf
\f[C]
map <c-a> down
\f[R]
.fi
.PP
Keys combined with the alt key are assigned in two different ways
depending on the behavior of your terminal.
Older terminals (e.g.
xterm) may set the 8th bit of a character when the alt key is pressed.
On these terminals, you can use the corresponding byte for the mapping:
.IP
.nf
\f[C]
map \['a] down
\f[R]
.fi
.PP
Newer terminals (e.g.
gnome-terminal) may prefix the key with an escape key when the alt key
is pressed.
lf uses the escape delaying mechanism to recognize alt keys in these
terminals (delay is 100ms).
On these terminals, keys combined with the alt key are prefixed with an
\f[C]a\f[R] character:
.IP
.nf
\f[C]
map <a-a> down
\f[R]
.fi
.PP
It is possible to combine special keys with modifiers:
.IP
.nf
\f[C]
map <a-enter> down
\f[R]
.fi
.PP
WARNING: Some key combinations will likely be intercepted by your OS,
window manager, or terminal.
Other key combinations cannot be recognized by lf due to the way
terminals work (e.g.
\f[C]Ctrl+h\f[R] combination sends a backspace key instead).
The easiest way to find out the name of a key combination and whether it
will work on your system is to press the key while lf is running and
read the name from the \f[C]unknown mapping\f[R] error.
.PP
Mouse buttons are prefixed with an \f[C]m\f[R] character:
.IP
.nf
\f[C]
map <m-1> down  # primary
map <m-2> down  # secondary
map <m-3> down  # middle
map <m-4> down
map <m-5> down
map <m-6> down
map <m-7> down
map <m-8> down
\f[R]
.fi
.PP
Mouse wheel events are also prefixed with an \f[C]m\f[R] character:
.IP
.nf
\f[C]
map <m-up>    down
map <m-down>  down
map <m-left>  down
map <m-right> down
\f[R]
.fi
.SH PUSH MAPPINGS
.PP
The usual way to map a key sequence is to assign it to a named or
unnamed command.
While this provides a clean way to remap built-in keys as well as other
commands, it can be limiting at times.
For this reason, the \f[C]push\f[R] command is provided by lf.
This command is used to simulate key pushes given as its arguments.
You can \f[C]map\f[R] a key to a \f[C]push\f[R] command with an argument
to create various keybindings.
.PP
This is mainly useful for two purposes.
First, it can be used to map a command with a command count:
.IP
.nf
\f[C]
map <c-j> push 10j
\f[R]
.fi
.PP
Second, it can be used to avoid typing the name when a command takes
arguments:
.IP
.nf
\f[C]
map r push :rename<space>
\f[R]
.fi
.PP
One thing to be careful of is that since the \f[C]push\f[R] command
works with keys instead of commands it is possible to accidentally
create recursive bindings:
.IP
.nf
\f[C]
map j push 2j
\f[R]
.fi
.PP
These types of bindings create a deadlock when executed.
.SH SHELL COMMANDS
.PP
Regular shell commands are the most basic command type that is useful
for many purposes.
For example, we can write a shell command to move the selected file(s)
to trash.
A first attempt to write such a command may look like this:
.IP
.nf
\f[C]
cmd trash ${{
    mkdir -p \[ti]/.trash
    if [ -z \[dq]$fs\[dq] ]; then
        mv \[dq]$f\[dq] \[ti]/.trash
    else
        IFS=\[dq]$(printf \[aq]\[rs]n\[rs]t\[aq])\[dq]; mv $fs \[ti]/.trash
    fi
}}
\f[R]
.fi
.PP
We check \f[C]$fs\f[R] to see if there are any selected files.
Otherwise, we just delete the current file.
Since this is such a common pattern, a separate \f[C]$fx\f[R] variable
is provided.
We can use this variable to get rid of the conditional:
.IP
.nf
\f[C]
cmd trash ${{
    mkdir -p \[ti]/.trash
    IFS=\[dq]$(printf \[aq]\[rs]n\[rs]t\[aq])\[dq]; mv $fx \[ti]/.trash
}}
\f[R]
.fi
.PP
The trash directory is checked each time the command is executed.
We can move it outside of the command so it would only run once at
startup:
.IP
.nf
\f[C]
${{ mkdir -p \[ti]/.trash }}

cmd trash ${{ IFS=\[dq]$(printf \[aq]\[rs]n\[rs]t\[aq])\[dq]; mv $fx \[ti]/.trash }}
\f[R]
.fi
.PP
Since these are one-liners, we can drop \f[C]{{\f[R] and \f[C]}}\f[R]:
.IP
.nf
\f[C]
$mkdir -p \[ti]/.trash

cmd trash $IFS=\[dq]$(printf \[aq]\[rs]n\[rs]t\[aq])\[dq]; mv $fx \[ti]/.trash
\f[R]
.fi
.PP
Finally, note that we set the \f[C]IFS\f[R] variable manually in these
commands.
Instead, we could use the \f[C]ifs\f[R] option to set it for all shell
commands (i.e.
\f[C]set ifs \[dq]\[rs]n\[dq]\f[R]).
This can be especially useful for interactive use (e.g.
\f[C]$rm $f\f[R] or \f[C]$rm $fs\f[R] would simply work).
This option is not set by default as it can behave unexpectedly for new
users.
However, use of this option is highly recommended and it is assumed in
the rest of the documentation.
.SH PIPING SHELL COMMANDS
.PP
Regular shell commands have some limitations in some cases.
When an output or error message is given and the command exits
afterwards, the ui is immediately resumed and there is no way to see the
message without dropping to shell again.
Also, even when there is no output or error, the UI still needs to be
paused while the command is running.
This can cause flickering on the screen for short commands and similar
distractions for longer commands.
.PP
Instead of pausing the UI, piping shell commands connect stdin, stdout,
and stderr of the command to the statline at the bottom of the UI.
This can be useful for programs following the Unix philosophy to give no
output in the success case, and brief error messages or prompts in other
cases.
.PP
For example, following rename command prompts for overwrite in the
statline if there is an existing file with the given name:
.IP
.nf
\f[C]
cmd rename %mv -i $f $1
\f[R]
.fi
.PP
You can also output error messages in the command and it will show up in
the statline.
For example, an alternative rename command may look like this:
.IP
.nf
\f[C]
cmd rename %[ -e $1 ] && printf \[dq]file exists\[dq] || mv $f $1
\f[R]
.fi
.PP
Note that input is line buffered and output and error are byte buffered.
.SH WAITING SHELL COMMANDS
.PP
Waiting shell commands are similar to regular shell commands except that
they wait for a key press when the command is finished.
These can be useful to see the output of a program before the UI is
resumed.
Waiting shell commands are more appropriate than piping shell commands
when the command is verbose and the output is best displayed as
multiline.
.SH ASYNCHRONOUS SHELL COMMANDS
.PP
Asynchronous shell commands are used to start a command in the
background and then resume operation without waiting for the command to
finish.
Stdin, stdout, and stderr of the command are neither connected to the
terminal nor the UI.
.SH REMOTE COMMANDS
.PP
One of the more advanced features in lf is remote commands.
All clients connect to a server on startup.
It is possible to send commands to all or any of the connected clients
over the common server.
This is used internally to notify file selection changes to other
clients.
.PP
To use this feature, you need to use a client which supports
communicating with a Unix domain socket.
OpenBSD implementation of netcat (nc) is one such example.
You can use it to send a command to the socket file:
.IP
.nf
\f[C]
echo \[aq]send echo hello world\[aq] | nc -U ${XDG_RUNTIME_DIR:-/tmp}/lf.${USER}.sock
\f[R]
.fi
.PP
Since such a client may not be available everywhere, lf comes bundled
with a command line flag to be used as such.
When using lf, you do not need to specify the address of the socket
file.
This is the recommended way of using remote commands since it is shorter
and immune to socket file address changes:
.IP
.nf
\f[C]
lf -remote \[aq]send echo hello world\[aq]
\f[R]
.fi
.PP
In this command \f[C]send\f[R] is used to send the rest of the string as
a command to all connected clients.
You can optionally give it an ID number to send a command to a single
client:
.IP
.nf
\f[C]
lf -remote \[aq]send 1234 echo hello world\[aq]
\f[R]
.fi
.PP
All clients have a unique id number but you may not be aware of the id
number when you are writing a command.
For this purpose, an \f[C]$id\f[R] variable is exported to the
environment for shell commands.
The value of this variable is set to the process ID of the client.
You can use it to send a remote command from a client to the server
which in return sends a command back to itself.
So now you can display a message in the current client by calling the
following in a shell command:
.IP
.nf
\f[C]
lf -remote \[dq]send $id echo hello world\[dq]
\f[R]
.fi
.PP
Since lf does not have control flow syntax, remote commands are used for
such needs.
For example, you can configure the number of columns in the UI with
respect to the terminal width as follows:
.IP
.nf
\f[C]
cmd recol %{{
    if [ $lf_width -le 80 ]; then
        lf -remote \[dq]send $id set ratios 1:2\[dq]
    elif [ $lf_width -le 160 ]; then
        lf -remote \[dq]send $id set ratios 1:2:3\[dq]
    else
        lf -remote \[dq]send $id set ratios 1:2:3:5\[dq]
    fi
}}
\f[R]
.fi
.PP
In addition, the \f[C]query\f[R] command can be used to obtain
information about a specific lf instance by providing its id:
.IP
.nf
\f[C]
lf -remote \[dq]query $id maps\[dq]
\f[R]
.fi
.PP
The following types of information are supported:
.IP
.nf
\f[C]
maps     list of mappings created by the \[aq]map\[aq] command
cmaps    list of mappings created by the \[aq]cmap\[aq] command
cmds     list of commands created by the \[aq]cmd\[aq] command
jumps    contents of the jump list, showing previously visited locations
history  list of previously executed commands on the command line
\f[R]
.fi
.PP
This is useful for scripting actions based on the internal state of lf.
For example, to select a previous command using fzf and execute it:
.IP
.nf
\f[C]
map <a-h> ${{
    clear
    cmd=$(
        lf -remote \[dq]query $id history\[dq] |
        awk -F\[aq]\[rs]t\[aq] \[aq]NR > 1 { print $NF}\[aq] |
        sort -u |
        fzf --reverse --prompt=\[aq]Execute command: \[aq]
    )
    lf -remote \[dq]send $id $cmd\[dq]
}}
\f[R]
.fi
.PP
There is also a \f[C]quit\f[R] command to quit the server when there are
no connected clients left, and a \f[C]quit!\f[R] command to force quit
the server by closing client connections first:
.IP
.nf
\f[C]
lf -remote \[aq]quit\[aq]
lf -remote \[aq]quit!\[aq]
\f[R]
.fi
.PP
Lastly, there is a \f[C]conn\f[R] command to connect the server to a
client.
This should not be needed for users.
.SH FILE OPERATIONS
.PP
lf uses its own built-in copy and move operations by default.
These are implemented as asynchronous operations and progress is shown
in the bottom ruler.
These commands do not overwrite existing files or directories with the
same name.
Instead, a suffix that is compatible with the
\f[C]--backup=numbered\f[R] option in GNU cp is added to the new files
or directories.
Only file modes and (some) timestamps can be preserved (see
\f[C]preserve\f[R] option), all other attributes are ignored including
ownership, context, and xattr.
Special files such as character and block devices, named pipes, and
sockets are skipped and links are not followed.
Moving is performed using the rename operation of the underlying OS.
For cross-device moving, lf falls back to copying and then deletes the
original files if there are no errors.
Operation errors are shown in the message line as well as the log file
and they do not preemptively finish the corresponding file operation.
.PP
File operations can be performed on the currently selected file or on
multiple files by selecting them first.
When you \f[C]copy\f[R] a file, lf doesn\[aq]t actually copy the file on
the disk, but only records its name to a file.
The actual file copying takes place when you \f[C]paste\f[R].
Similarly \f[C]paste\f[R] after a \f[C]cut\f[R] operation moves the
file.
.PP
You can customize copy and move operations by defining a \f[C]paste\f[R]
command.
This is a special command that is called when it is defined instead of
the built-in implementation.
You can use the following example as a starting point:
.IP
.nf
\f[C]
cmd paste %{{
    load=$(cat \[ti]/.local/share/lf/files)
    mode=$(echo \[dq]$load\[dq] | sed -n \[aq]1p\[aq])
    list=$(echo \[dq]$load\[dq] | sed \[aq]1d\[aq])
    if [ $mode = \[aq]copy\[aq] ]; then
        cp -R $list .
    elif [ $mode = \[aq]move\[aq] ]; then
        mv $list .
        rm \[ti]/.local/share/lf/files
        lf -remote \[aq]send clear\[aq]
    fi
}}
\f[R]
.fi
.PP
Some useful things to be considered are to use the backup
(\f[C]--backup\f[R]) and/or preserve attributes (\f[C]-a\f[R]) options
with \f[C]cp\f[R] and \f[C]mv\f[R] commands if they support it (i.e.
GNU implementation), change the command type to asynchronous, or use
\f[C]rsync\f[R] command with progress bar option for copying and feed
the progress to the client periodically with remote \f[C]echo\f[R]
calls.
.PP
By default, lf does not assign \f[C]delete\f[R] command to a key to
protect new users.
You can customize file deletion by defining a \f[C]delete\f[R] command.
You can also assign a key to this command if you like.
An example command to move selected files to a trash folder and remove
files completely after a prompt is provided in the example configuration
file.
.SH SEARCHING FILES
.PP
There are two mechanisms implemented in lf to search a file in the
current directory.
Searching is the traditional method to move the selection to a file
matching a given pattern.
Finding is an alternative way to search for a pattern possibly using
fewer keystrokes.
.PP
The searching mechanism is implemented with commands \f[C]search\f[R]
(default \f[C]/\f[R]), \f[C]search-back\f[R] (default \f[C]?\f[R]),
\f[C]search-next\f[R] (default \f[C]n\f[R]), and \f[C]search-prev\f[R]
(default \f[C]N\f[R]).
You can enable \f[C]globsearch\f[R] option to match with a glob pattern.
Globbing supports \f[C]*\f[R] to match any sequence, \f[C]?\f[R] to
match any character, and \f[C][...]\f[R] or \f[C][\[ha]...]\f[R] to
match character sets or ranges.
You can enable \f[C]incsearch\f[R] option to jump to the current match
at each keystroke while typing.
In this mode, you can either use \f[C]cmd-enter\f[R] to accept the
search or use \f[C]cmd-escape\f[R] to cancel the search.
You can also map some other commands with \f[C]cmap\f[R] to accept the
search and execute the command immediately afterwards.
For example, you can use the right arrow key to finish the search and
open the selected file with the following mapping:
.IP
.nf
\f[C]
cmap <right> :cmd-enter; open
\f[R]
.fi
.PP
The finding mechanism is implemented with commands \f[C]find\f[R]
(default \f[C]f\f[R]), \f[C]find-back\f[R] (default \f[C]F\f[R]),
\f[C]find-next\f[R] (default \f[C];\f[R]), \f[C]find-prev\f[R] (default
\f[C],\f[R]).
You can disable \f[C]anchorfind\f[R] option to match a pattern at an
arbitrary position in the filename instead of the beginning.
You can set the number of keys to match using \f[C]findlen\f[R] option.
If you set this value to zero, then the keys are read until there is
only a single match.
The default values of these two options are set to jump to the first
file with the given initial.
.PP
Some options effect both searching and finding.
You can disable \f[C]wrapscan\f[R] option to prevent searches from being
wrapped around at the end of the file list.
You can disable \f[C]ignorecase\f[R] option to match cases in the
pattern and the filename.
This option is already automatically overridden if the pattern contains
upper-case characters.
You can disable \f[C]smartcase\f[R] option to disable this behavior.
Two similar options \f[C]ignoredia\f[R] and \f[C]smartdia\f[R] are
provided to control matching diacritics in Latin letters.
.SH OPENING FILES
.PP
You can define an \f[C]open\f[R] command (default \f[C]l\f[R] and
\f[C]<right>\f[R]) to configure file opening.
This command is only called when the current file is not a directory,
otherwise, the directory is entered instead.
You can define it just as you would define any other command:
.IP
.nf
\f[C]
cmd open $vi $fx
\f[R]
.fi
.PP
It is possible to use different command types:
.IP
.nf
\f[C]
cmd open &xdg-open $f
\f[R]
.fi
.PP
You may want to use either file extensions or mime types from
\f[C]file\f[R] command:
.IP
.nf
\f[C]
cmd open ${{
    case $(file --mime-type -Lb $f) in
        text/*) vi $fx;;
        *) for f in $fx; do xdg-open $f > /dev/null 2> /dev/null & done;;
    esac
}}
\f[R]
.fi
.PP
You may want to use \f[C]setsid\f[R] before your opener command to have
persistent processes that continue to run after lf quits.
.PP
Regular shell commands (i.e.
\f[C]$\f[R]) drop to the terminal which results in a flicker for
commands that finish immediately (e.g.
\f[C]xdg-open\f[R] in the above example).
If you want to use asynchronous shell commands (i.e.
\f[C]&\f[R]) but also want to use the terminal when necessary (e.g.
\f[C]vi\f[R] in the above example), you can use a remote command:
.IP
.nf
\f[C]
cmd open &{{
    case $(file --mime-type -Lb $f) in
        text/*) lf -remote \[dq]send $id \[rs]$vi \[rs]$fx\[dq];;
        *) for f in $fx; do xdg-open $f > /dev/null 2> /dev/null & done;;
    esac
}}
\f[R]
.fi
.PP
Note that asynchronous shell commands run in their own process group by
default so they do not require the manual use of \f[C]setsid\f[R].
.PP
The following command is provided by default:
.IP
.nf
\f[C]
cmd open &$OPENER $f
\f[R]
.fi
.PP
You may also use any other existing file openers as you like.
Possible options are \f[C]libfile-mimeinfo-perl\f[R] (executable name is
\f[C]mimeopen\f[R]), \f[C]rifle\f[R] (ranger\[aq]s default file opener),
or \f[C]mimeo\f[R] to name a few.
.SH PREVIEWING FILES
.PP
lf previews files on the preview pane by printing the file until the end
or until the preview pane is filled.
This output can be enhanced by providing a custom preview script for
filtering.
This can be used to highlight source codes, list contents of archive
files or view PDF or image files to name a few.
For coloring lf recognizes ANSI escape codes.
.PP
To use this feature, you need to set the value of \f[C]previewer\f[R]
option to the path of an executable file.
Five arguments are passed to the file, (1) current file name, (2) width,
(3) height, (4) horizontal position, and (5) vertical position of
preview pane respectively.
The output of the execution is printed in the preview pane.
You may also want to use the same script in your pager mapping as well:
.IP
.nf
\f[C]
set previewer \[ti]/.config/lf/pv.sh
map i $\[ti]/.config/lf/pv.sh $f | less -R
\f[R]
.fi
.PP
For \f[C]less\f[R] pager, you may instead utilize \f[C]LESSOPEN\f[R]
mechanism so that useful information about the file such as the full
path of the file can still be displayed in the statusline below:
.IP
.nf
\f[C]
set previewer \[ti]/.config/lf/pv.sh
map i $LESSOPEN=\[aq]| \[ti]/.config/lf/pv.sh %s\[aq] less -R $f
\f[R]
.fi
.PP
Since this script is called for each file selection change it needs to
be as efficient as possible and this responsibility is left to the user.
You may use file extensions to determine the type of file more
efficiently compared to obtaining mime types from \f[C]file\f[R]
command.
Extensions can then be used to match cleanly within a conditional:
.IP
.nf
\f[C]
#!/bin/sh

case \[dq]$1\[dq] in
    *.tar*) tar tf \[dq]$1\[dq];;
    *.zip) unzip -l \[dq]$1\[dq];;
    *.rar) unrar l \[dq]$1\[dq];;
    *.7z) 7z l \[dq]$1\[dq];;
    *.pdf) pdftotext \[dq]$1\[dq] -;;
    *) highlight -O ansi \[dq]$1\[dq];;
esac
\f[R]
.fi
.PP
Another important consideration for efficiency is the use of programs
with short startup times for preview.
For this reason, \f[C]highlight\f[R] is recommended over
\f[C]pygmentize\f[R] for syntax highlighting.
Besides, it is also important that the application processes the file on
the fly rather than first reading it to the memory and then doing the
processing afterwards.
This is especially relevant for big files.
lf automatically closes the previewer script output pipe with a SIGPIPE
when enough lines are read.
When everything else fails, you can make use of the height argument to
only feed the first portion of the file to a program for preview.
Note that some programs may not respond well to SIGPIPE to exit with a
non-zero return code and avoid caching.
You may add a trailing \f[C]|| true\f[R] command to avoid such errors:
.IP
.nf
\f[C]
highlight -O ansi \[dq]$1\[dq] || true
\f[R]
.fi
.PP
You may also use an existing preview filter as you like.
Your system may already come with a preview filter named
\f[C]lesspipe\f[R].
These filters may have a mechanism to add user customizations as well.
See the related documentation for more information.
.SH CHANGING DIRECTORY
.PP
lf changes the working directory of the process to the current directory
so that shell commands always work in the displayed directory.
After quitting, it returns to the original directory where it is first
launched like all shell programs.
If you want to stay in the current directory after quitting, you can use
one of the example lfcd wrapper shell scripts provided in the repository
at <https://github.com/gokcehan/lf/tree/master/etc>
.PP
There is a special command \f[C]on-cd\f[R] that runs a shell command
when it is defined and the directory is changed.
You can define it just as you would define any other command:
.IP
.nf
\f[C]
cmd on-cd &{{
    bash -c \[aq]
    # display git repository status in your prompt
    source /usr/share/git/completion/git-prompt.sh
    GIT_PS1_SHOWDIRTYSTATE=auto
    GIT_PS1_SHOWSTASHSTATE=auto
    GIT_PS1_SHOWUNTRACKEDFILES=auto
    GIT_PS1_SHOWUPSTREAM=auto
    git=$(__git_ps1 \[dq] (%s)\[dq])
    fmt=\[dq]\[rs]033[32;1m%u\[at]%h\[rs]033[0m:\[rs]033[34;1m%d\[rs]033[0m\[rs]033[1m%f$git\[rs]033[0m\[dq]
    lf -remote \[dq]send $id set promptfmt \[rs]\[dq]$fmt\[rs]\[dq]\[dq]
    \[aq]
}}
\f[R]
.fi
.PP
If you want to print escape sequences, you may redirect \f[C]printf\f[R]
output to \f[C]/dev/tty\f[R].
The following xterm-specific escape sequence sets the terminal title to
the working directory:
.IP
.nf
\f[C]
cmd on-cd &{{
    printf \[dq]\[rs]033]0; $PWD\[rs]007\[dq] > /dev/tty
}}
\f[R]
.fi
.PP
This command runs whenever you change the directory but not on startup.
You can add an extra call to make it run on startup as well:
.IP
.nf
\f[C]
cmd on-cd &{{ ... }}
on-cd
\f[R]
.fi
.PP
Note that all shell commands are possible but \f[C]%\f[R] and
\f[C]&\f[R] are usually more appropriate as \f[C]$\f[R] and \f[C]!\f[R]
causes flickers and pauses respectively.
.PP
There is also a \f[C]pre-cd\f[R] command, that works like
\f[C]on-cd\f[R], but is run before the directory is actually changed.
.SH COLORS
.PP
lf tries to automatically adapt its colors to the environment.
It starts with a default color scheme and updates colors using values of
existing environment variables possibly by overwriting its previous
values.
Colors are set in the following order:
.IP "1." 3
default
.IP "2." 3
LSCOLORS (Mac/BSD ls)
.IP "3." 3
LS_COLORS (GNU ls)
.IP "4." 3
LF_COLORS (lf specific)
.IP "5." 3
colors file (lf specific)
.PP
Please refer to the corresponding man pages for more information about
\f[C]LSCOLORS\f[R] and \f[C]LS_COLORS\f[R].
\f[C]LF_COLORS\f[R] is provided with the same syntax as
\f[C]LS_COLORS\f[R] in case you want to configure colors only for lf but
not ls.
This can be useful since there are some differences between ls and lf,
though one should expect the same behavior for common cases.
The colors file (refer to the CONFIGURATION
section (https://github.com/gokcehan/lf/blob/master/doc.md#configuration))
is provided for easier configuration without environment variables.
This file should consist of whitespace-separated pairs with a
\f[C]#\f[R] character to start comments until the end of the line.
.PP
You can configure lf colors in two different ways.
First, you can only configure 8 basic colors used by your terminal and
lf should pick up those colors automatically.
Depending on your terminal, you should be able to select your colors
from a 24-bit palette.
This is the recommended approach as colors used by other programs will
also match each other.
.PP
Second, you can set the values of environment variables or colors file
mentioned above for fine-grained customization.
Note that \f[C]LS_COLORS/LF_COLORS\f[R] are more powerful than
\f[C]LSCOLORS\f[R] and they can be used even when GNU programs are not
installed on the system.
You can combine this second method with the first method for the best
results.
.PP
Lastly, you may also want to configure the colors of the prompt line to
match the rest of the colors.
Colors of the prompt line can be configured using the
\f[C]promptfmt\f[R] option which can include hardcoded colors as ANSI
escapes.
See the default value of this option to have an idea about how to color
this line.
.PP
It is worth noting that lf uses as many colors advertised by your
terminal\[aq]s entry in terminfo or infocmp databases on your system.
If an entry is not present, it falls back to an internal database.
If your terminal supports 24-bit colors but either does not have a
database entry or does not advertise all capabilities, you can enable
support by setting the \f[C]$COLORTERM\f[R] variable to
\f[C]truecolor\f[R] or ensuring \f[C]$TERM\f[R] is set to a value that
ends with \f[C]-truecolor\f[R].
.PP
Default lf colors are mostly taken from GNU dircolors defaults.
These defaults use 8 basic colors and bold attribute.
Default dircolors entries with background colors are simplified to avoid
confusion with current file selection in lf.
Similarly, there are only file type matchings and extension matchings
are left out for simplicity.
Default values are as follows given with their matching order in lf:
.IP
.nf
\f[C]
ln  01;36
or  31;01
tw  01;34
ow  01;34
st  01;34
di  01;34
pi  33
so  01;35
bd  33;01
cd  33;01
su  01;32
sg  01;32
ex  01;32
fi  00
\f[R]
.fi
.PP
Note that lf first tries matching file names and then falls back to file
types.
The full order of matchings from most specific to least are as follows:
.IP "1." 3
Full Path (e.g.
\f[C]\[ti]/.config/lf/lfrc\f[R])
.IP "2." 3
Dir Name (e.g.
\f[C].git/\f[R]) (only matches dirs with a trailing slash at the end)
.IP "3." 3
File Type (e.g.
\f[C]ln\f[R]) (except \f[C]fi\f[R])
.IP "4." 3
File Name (e.g.
\f[C]README*\f[R])
.IP "5." 3
File Name (e.g.
\f[C]*README\f[R])
.IP "6." 3
Base Name (e.g.
\f[C]README.*\f[R])
.IP "7." 3
Extension (e.g.
\f[C]*.txt\f[R])
.IP "8." 3
Default (i.e.
\f[C]fi\f[R])
.PP
For example, given a regular text file \f[C]/path/to/README.txt\f[R],
the following entries are checked in the configuration and the first one
to match is used:
.IP "1." 3
\f[C]/path/to/README.txt\f[R]
.IP "2." 3
(skipped since the file is not a directory)
.IP "3." 3
(skipped since the file is of type \f[C]fi\f[R])
.IP "4." 3
\f[C]README.txt*\f[R]
.IP "5." 3
\f[C]*README.txt\f[R]
.IP "6." 3
\f[C]README.*\f[R]
.IP "7." 3
\f[C]*.txt\f[R]
.IP "8." 3
\f[C]fi\f[R]
.PP
Given a regular directory \f[C]/path/to/example.d\f[R], the following
entries are checked in the configuration and the first one to match is
used:
.IP "1." 3
\f[C]/path/to/example.d\f[R]
.IP "2." 3
\f[C]example.d/\f[R]
.IP "3." 3
\f[C]di\f[R]
.IP "4." 3
\f[C]example.d*\f[R]
.IP "5." 3
\f[C]*example.d\f[R]
.IP "6." 3
\f[C]example.*\f[R]
.IP "7." 3
\f[C]*.d\f[R]
.IP "8." 3
\f[C]fi\f[R]
.PP
Note that glob-like patterns do not perform glob matching for
performance reasons.
.PP
For example, you can set a variable as follows:
.IP
.nf
\f[C]
export LF_COLORS=\[dq]\[ti]/Documents=01;31:\[ti]/Downloads=01;31:\[ti]/.local/share=01;31:\[ti]/.config/lf/lfrc=31:.git/=01;32:.git*=32:*.gitignore=32:*Makefile=32:README.*=33:*.txt=34:*.md=34:ln=01;36:di=01;34:ex=01;32:\[dq]
\f[R]
.fi
.PP
Having all entries on a single line can make it hard to read.
You may instead divide it into multiple lines in between double quotes
by escaping newlines with backslashes as follows:
.IP
.nf
\f[C]
export LF_COLORS=\[dq]\[rs]
\[ti]/Documents=01;31:\[rs]
\[ti]/Downloads=01;31:\[rs]
\[ti]/.local/share=01;31:\[rs]
\[ti]/.config/lf/lfrc=31:\[rs]
\&.git/=01;32:\[rs]
\&.git*=32:\[rs]
*.gitignore=32:\[rs]
*Makefile=32:\[rs]
README.*=33:\[rs]
*.txt=34:\[rs]
*.md=34:\[rs]
ln=01;36:\[rs]
di=01;34:\[rs]
ex=01;32:\[rs]
\[dq]
\f[R]
.fi
.PP
The \f[C]ln\f[R] entry supports the special value \f[C]target\f[R],
which will use the link target to select a style.
File name rules will still apply based on the link\[aq]s name -- this
mirrors GNU\[aq]s \f[C]ls\f[R] and \f[C]dircolors\f[R] behavior.
Having such a long variable definition in a shell configuration file
might be undesirable.
You may instead use the colors file (refer to the CONFIGURATION
section (https://github.com/gokcehan/lf/blob/master/doc.md#configuration))
for configuration.
A sample colors file can be found at
<https://github.com/gokcehan/lf/blob/master/etc/colors.example> You may
also see the wiki page for ANSI escape codes
<https://en.wikipedia.org/wiki/ANSI_escape_code>
.SH ICONS
.PP
Icons are configured using \f[C]LF_ICONS\f[R] environment variable or an
icons file (refer to the CONFIGURATION
section (https://github.com/gokcehan/lf/blob/master/doc.md#configuration)).
The variable uses the same syntax as \f[C]LS_COLORS/LF_COLORS\f[R].
Instead of colors, you should put a single characters as values of
entries.
The \f[C]ln\f[R] entry supports the special value \f[C]target\f[R],
which will use the link target to select a icon.
File name rules will still apply based on the link\[aq]s name -- this
mirrors GNU\[aq]s \f[C]ls\f[R] and \f[C]dircolors\f[R] behavior.
The icons file (refer to the CONFIGURATION
section (https://github.com/gokcehan/lf/blob/master/doc.md#configuration))
should consist of whitespace-separated arrays with a \f[C]#\f[R]
character to start comments until the end of the line.
Each line should contain 1-3 columns, first column is filetype or
filename pattern, second column is the icon, third column is an optional
icon color.
If there is only one column, means to disable rule for this filetype or
pattern.
Do not forget to add \f[C]set icons true\f[R] to your \f[C]lfrc\f[R] to
see the icons.
Default values are as follows given with their matching order in lf:
.IP
.nf
\f[C]
ln  l
or  l
tw  t
ow  d
st  t
di  d
pi  p
so  s
bd  b
cd  c
su  u
sg  g
ex  x
fi  -
\f[R]
.fi
.PP
A sample icons file can be found at
<https://github.com/gokcehan/lf/blob/master/etc/icons.example>
.PP
A sample colored icons file can be found at
<https://github.com/gokcehan/lf/blob/master/etc/icons_colored.example>
